这个题思路也不难，网站给出的 solution 中最 brute 的方法我都没想到，效率太低，我想到了每次查询新添加的元素是否存在，写了 solution1。
主要就是找开始和结束的位置。开始位置 i 从 0 开始遍历，结束位置 j 从 i+1 开始遍历，找到重复的字符就 break 出去。

solution2 主要是让开始位置跳跃前进，不要每次都只增加 1，而是从 map 里指明的重复字符的位置开始往后。

但上面 2 种方法还是用了 2 层循环。而且需要存储 string s 中的所有字符。

终于想明白 solution page 中的 slide window 是什么意思了。之前一直困惑为啥答案中可以用一轮循环完成任务，就是因为 slide window 的思想。其实如果子串的末尾已经到了整个字符串的结束了，那就没有必要再遍历子串的起始位置了，因为继续遍历下去的话子串越来越小。

抄了 discuss 里面的一个 solution4。代码很精简了，但是也存在占内存的问题。而且要注意，这里 start 的使用
