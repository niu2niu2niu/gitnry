分析：在很多C语言教科书中讲到递归函数的时候，都会用Fibonacci作为例子。
因此很多程序员对这道题的递归解法非常熟悉，看到题目就能写出递归求解的代码。

但是，教科书上反复用这个题目来讲解递归函数，并不能说明递归解法最适合这道题目。
我们以求解f(10)作为例子来分析递归求解的过程。要求得f(10)，需要求得f(9)和f(8)。
同样，要求得f(9)，要先求得f(8)和f(7)……我们用树形结构来表示这种依赖关系
                  f(10)
               /        \
            f(9)         f(8)
          /     \       /    \
       f(8)     f(7)  f(6)   f(5)
      /   \     /   \ 
   f(7)  f(6)  f(6) f(5)
我们不难发现在这棵树中有很多结点会重复的，而且重复的结点数会随着n的增大而急剧增加。
这意味这计算量会随着n的增大而急剧增大。事实上，用递归方法计算的时间复杂度是以n的指数的方式递增的。
大家可以求Fibonacci的第100项试试，感受一下这样递归会慢到什么程度。
在我的机器上，连续运行了一个多小时也没有出来结果。
其实改进的方法并不复杂。上述方法之所以慢是因为重复的计算太多，只要避免重复计算就行了。
比如我们可以把已经得到的数列中间项保存起来，如果下次需要计算的时候我们先查找一下，
如果前面已经计算过了就不用再次计算了。
更简单的办法是从下往上计算，首先根据f(0)和f(1)算出f(2)，在根据f(1)和f(2)算出f(3)……依此类推就可以算出第n项了。
很容易理解，这种思路的时间复杂度是O(n)。

这还不是最快的方法。下面介绍一种时间复杂度是O(logn)的方法。
在介绍这种方法之前，先介绍一个数学公式：
{f(n), f(n-1), f(n-1), f(n-2)} ={1, 1, 1,0}^n-1
(注：{f(n+1), f(n), f(n), f(n-1)}表示一个矩阵。
在矩阵中第一行第一列是f(n+1)，第一行第二列是f(n)，第二行第一列是f(n)，第二行第二列是f(n-1)。)
有了这个公式，要求得f(n)，我们只需要求得矩阵{1, 1, 1,0}的n-1次方，
因为矩阵{1, 1, 1,0}的n-1次方的结果的第一行第一列就是f(n)。
这个数学公式用数学归纳法不难证明。感兴趣的朋友不妨自己证明一下。
现在的问题转换为求矩阵{1, 1, 1, 0}的乘方。
如果简单第从0开始循环，n次方将需要n次运算，并不比前面的方法要快。
但我们可以考虑乘方的如下性质：
        /  an/2*an/2                      n为偶数时
an=
        \  a(n-1)/2*a(n-1)/2            n为奇数时
要求得n次方，我们先求得n/2次方，再把n/2的结果平方一下。
如果把求n次方的问题看成一个大问题，把求n/2看成一个较小的问题。
这种把大问题分解成一个或多个小问题的思路我们称之为分治法。这样求n次方就只需要logn次运算了。
实现这种方式时，首先需要定义一个2×2的矩阵，并且定义好矩阵的乘法以及乘方运算。
当这些运算定义好了之后，剩下的事情就变得非常简单。
